// @generated by protobuf-ts 2.11.0 with parameter generate_dependencies,long_type_string,client_generic
// @generated from protobuf file "sessionsource.proto" (package "sessionsource", syntax proto3)
// tslint:disable
import { Respone } from "./common";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Duration } from "./google/protobuf/duration";
import { Timestamp } from "./google/protobuf/timestamp";
import { RecorderStatus } from "./common";
/**
 * @generated from protobuf message sessionsource.StreamRecordersRequest
 */
export interface StreamRecordersRequest {
}
/**
 * @generated from protobuf message sessionsource.RecordereRemoved
 */
export interface RecordereRemoved {
}
/**
 * @generated from protobuf message sessionsource.Recorder
 */
export interface Recorder {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
    /**
     * @generated from protobuf field: string recorderName = 2
     */
    recorderName: string;
    /**
     * @generated from protobuf oneof: info
     */
    info: {
        oneofKind: "status";
        /**
         * @generated from protobuf field: common.RecorderStatus status = 3
         */
        status: RecorderStatus;
    } | {
        oneofKind: "removed";
        /**
         * @generated from protobuf field: sessionsource.RecordereRemoved removed = 4
         */
        removed: RecordereRemoved;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message sessionsource.StreamSessionRequest
 */
export interface StreamSessionRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
}
/**
 * @generated from protobuf message sessionsource.SegmentInfo
 */
export interface SegmentInfo {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timeStart = 1
     */
    timeStart?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timeEnd = 2
     */
    timeEnd?: Timestamp;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: sessionsource.SegmentState state = 4
     */
    state: SegmentState;
}
/**
 * @generated from protobuf message sessionsource.SegmentRemoved
 */
export interface SegmentRemoved {
}
/**
 * @generated from protobuf message sessionsource.Segment
 */
export interface Segment {
    /**
     * @generated from protobuf field: string segmentID = 1
     */
    segmentID: string;
    /**
     * @generated from protobuf oneof: info
     */
    info: {
        oneofKind: "updated";
        /**
         * @generated from protobuf field: sessionsource.SegmentInfo updated = 2
         */
        updated: SegmentInfo;
    } | {
        oneofKind: "removed";
        /**
         * @generated from protobuf field: sessionsource.SegmentRemoved removed = 3
         */
        removed: SegmentRemoved;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message sessionsource.SessionInfo
 */
export interface SessionInfo {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timeCreated = 2
     */
    timeCreated?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp timeFinished = 3
     */
    timeFinished?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Duration lifetime = 4
     */
    lifetime?: Duration;
    /**
     * @generated from protobuf field: string name = 5
     */
    name: string;
    /**
     * @generated from protobuf field: string audioFileName = 6
     */
    audioFileName: string;
    /**
     * @generated from protobuf field: string waveformDataFile = 7
     */
    waveformDataFile: string;
    /**
     * @generated from protobuf field: bool keep = 8
     */
    keep: boolean;
    /**
     * @generated from protobuf field: sessionsource.SessionState state = 9
     */
    state: SessionState;
    /**
     * @generated from protobuf field: repeated sessionsource.Segment segments = 10
     */
    segments: Segment[];
}
/**
 * @generated from protobuf message sessionsource.SessionRemoved
 */
export interface SessionRemoved {
}
/**
 * @generated from protobuf message sessionsource.Session
 */
export interface Session {
    /**
     * @generated from protobuf field: string ID = 1
     */
    iD: string;
    /**
     * @generated from protobuf oneof: info
     */
    info: {
        oneofKind: "updated";
        /**
         * @generated from protobuf field: sessionsource.SessionInfo updated = 2
         */
        updated: SessionInfo;
    } | {
        oneofKind: "removed";
        /**
         * @generated from protobuf field: sessionsource.SessionRemoved removed = 3
         */
        removed: SessionRemoved;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message sessionsource.SetKeepSessionRequest
 */
export interface SetKeepSessionRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
    /**
     * @generated from protobuf field: string sessionID = 2
     */
    sessionID: string;
    /**
     * @generated from protobuf field: bool keep = 3
     */
    keep: boolean;
}
/**
 * @generated from protobuf message sessionsource.DeleteSessionRequest
 */
export interface DeleteSessionRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
    /**
     * @generated from protobuf field: string sessionID = 2
     */
    sessionID: string;
}
/**
 * @generated from protobuf message sessionsource.SetNameRequest
 */
export interface SetNameRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
    /**
     * @generated from protobuf field: string sessionID = 2
     */
    sessionID: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
}
/**
 * @generated from protobuf message sessionsource.CreateSegmentRequest
 */
export interface CreateSegmentRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
    /**
     * @generated from protobuf field: string sessionID = 2
     */
    sessionID: string;
    /**
     * @generated from protobuf field: string segmentID = 3
     */
    segmentID: string;
    /**
     * @generated from protobuf field: sessionsource.SegmentInfo info = 4
     */
    info?: SegmentInfo;
}
/**
 * @generated from protobuf message sessionsource.UpdateSegmentRequest
 */
export interface UpdateSegmentRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
    /**
     * @generated from protobuf field: string sessionID = 2
     */
    sessionID: string;
    /**
     * @generated from protobuf field: string segmentID = 3
     */
    segmentID: string;
    /**
     * @generated from protobuf field: sessionsource.SegmentInfo info = 4
     */
    info?: SegmentInfo;
}
/**
 * @generated from protobuf message sessionsource.DeleteSegmentRequest
 */
export interface DeleteSegmentRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
    /**
     * @generated from protobuf field: string sessionID = 2
     */
    sessionID: string;
    /**
     * @generated from protobuf field: string segmentID = 3
     */
    segmentID: string;
}
/**
 * @generated from protobuf message sessionsource.RenderSegmentRequest
 */
export interface RenderSegmentRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
    /**
     * @generated from protobuf field: string sessionID = 2
     */
    sessionID: string;
    /**
     * @generated from protobuf field: string segmentID = 3
     */
    segmentID: string;
}
/**
 * @generated from protobuf message sessionsource.CutSessionRequest
 */
export interface CutSessionRequest {
    /**
     * @generated from protobuf field: string recorderID = 1
     */
    recorderID: string;
}
/**
 * @generated from protobuf enum sessionsource.SegmentState
 */
export enum SegmentState {
    /**
     * @generated from protobuf enum value: SEGMENT_STATE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SEGMENT_STATE_RENDERING = 1;
     */
    RENDERING = 1,
    /**
     * @generated from protobuf enum value: SEGMENT_STATE_FINISHED = 2;
     */
    FINISHED = 2,
    /**
     * @generated from protobuf enum value: SEGMENT_STATE_ERROR = 3;
     */
    ERROR = 3
}
/**
 * @generated from protobuf enum sessionsource.SessionState
 */
export enum SessionState {
    /**
     * @generated from protobuf enum value: SESSION_STATE_UNKNOWN = 0;
     */
    UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SESSION_STATE_RECORDING = 1;
     */
    RECORDING = 1,
    /**
     * @generated from protobuf enum value: SESSION_STATE_FINISHED = 2;
     */
    FINISHED = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class StreamRecordersRequest$Type extends MessageType<StreamRecordersRequest> {
    constructor() {
        super("sessionsource.StreamRecordersRequest", []);
    }
    create(value?: PartialMessage<StreamRecordersRequest>): StreamRecordersRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<StreamRecordersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamRecordersRequest): StreamRecordersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamRecordersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.StreamRecordersRequest
 */
export const StreamRecordersRequest = new StreamRecordersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordereRemoved$Type extends MessageType<RecordereRemoved> {
    constructor() {
        super("sessionsource.RecordereRemoved", []);
    }
    create(value?: PartialMessage<RecordereRemoved>): RecordereRemoved {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RecordereRemoved>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordereRemoved): RecordereRemoved {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordereRemoved, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.RecordereRemoved
 */
export const RecordereRemoved = new RecordereRemoved$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Recorder$Type extends MessageType<Recorder> {
    constructor() {
        super("sessionsource.Recorder", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "recorderName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "status", kind: "message", oneof: "info", T: () => RecorderStatus },
            { no: 4, name: "removed", kind: "message", oneof: "info", T: () => RecordereRemoved }
        ]);
    }
    create(value?: PartialMessage<Recorder>): Recorder {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        message.recorderName = "";
        message.info = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Recorder>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Recorder): Recorder {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                case /* string recorderName */ 2:
                    message.recorderName = reader.string();
                    break;
                case /* common.RecorderStatus status */ 3:
                    message.info = {
                        oneofKind: "status",
                        status: RecorderStatus.internalBinaryRead(reader, reader.uint32(), options, (message.info as any).status)
                    };
                    break;
                case /* sessionsource.RecordereRemoved removed */ 4:
                    message.info = {
                        oneofKind: "removed",
                        removed: RecordereRemoved.internalBinaryRead(reader, reader.uint32(), options, (message.info as any).removed)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Recorder, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        /* string recorderName = 2; */
        if (message.recorderName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.recorderName);
        /* common.RecorderStatus status = 3; */
        if (message.info.oneofKind === "status")
            RecorderStatus.internalBinaryWrite(message.info.status, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* sessionsource.RecordereRemoved removed = 4; */
        if (message.info.oneofKind === "removed")
            RecordereRemoved.internalBinaryWrite(message.info.removed, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.Recorder
 */
export const Recorder = new Recorder$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamSessionRequest$Type extends MessageType<StreamSessionRequest> {
    constructor() {
        super("sessionsource.StreamSessionRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamSessionRequest>): StreamSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        if (value !== undefined)
            reflectionMergePartial<StreamSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamSessionRequest): StreamSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.StreamSessionRequest
 */
export const StreamSessionRequest = new StreamSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SegmentInfo$Type extends MessageType<SegmentInfo> {
    constructor() {
        super("sessionsource.SegmentInfo", [
            { no: 1, name: "timeStart", kind: "message", T: () => Timestamp },
            { no: 2, name: "timeEnd", kind: "message", T: () => Timestamp },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "state", kind: "enum", T: () => ["sessionsource.SegmentState", SegmentState, "SEGMENT_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<SegmentInfo>): SegmentInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.state = 0;
        if (value !== undefined)
            reflectionMergePartial<SegmentInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SegmentInfo): SegmentInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp timeStart */ 1:
                    message.timeStart = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timeStart);
                    break;
                case /* google.protobuf.Timestamp timeEnd */ 2:
                    message.timeEnd = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timeEnd);
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* sessionsource.SegmentState state */ 4:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SegmentInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp timeStart = 1; */
        if (message.timeStart)
            Timestamp.internalBinaryWrite(message.timeStart, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp timeEnd = 2; */
        if (message.timeEnd)
            Timestamp.internalBinaryWrite(message.timeEnd, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* sessionsource.SegmentState state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.SegmentInfo
 */
export const SegmentInfo = new SegmentInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SegmentRemoved$Type extends MessageType<SegmentRemoved> {
    constructor() {
        super("sessionsource.SegmentRemoved", []);
    }
    create(value?: PartialMessage<SegmentRemoved>): SegmentRemoved {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SegmentRemoved>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SegmentRemoved): SegmentRemoved {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SegmentRemoved, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.SegmentRemoved
 */
export const SegmentRemoved = new SegmentRemoved$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Segment$Type extends MessageType<Segment> {
    constructor() {
        super("sessionsource.Segment", [
            { no: 1, name: "segmentID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "updated", kind: "message", oneof: "info", T: () => SegmentInfo },
            { no: 3, name: "removed", kind: "message", oneof: "info", T: () => SegmentRemoved }
        ]);
    }
    create(value?: PartialMessage<Segment>): Segment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.segmentID = "";
        message.info = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Segment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Segment): Segment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string segmentID */ 1:
                    message.segmentID = reader.string();
                    break;
                case /* sessionsource.SegmentInfo updated */ 2:
                    message.info = {
                        oneofKind: "updated",
                        updated: SegmentInfo.internalBinaryRead(reader, reader.uint32(), options, (message.info as any).updated)
                    };
                    break;
                case /* sessionsource.SegmentRemoved removed */ 3:
                    message.info = {
                        oneofKind: "removed",
                        removed: SegmentRemoved.internalBinaryRead(reader, reader.uint32(), options, (message.info as any).removed)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Segment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string segmentID = 1; */
        if (message.segmentID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.segmentID);
        /* sessionsource.SegmentInfo updated = 2; */
        if (message.info.oneofKind === "updated")
            SegmentInfo.internalBinaryWrite(message.info.updated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sessionsource.SegmentRemoved removed = 3; */
        if (message.info.oneofKind === "removed")
            SegmentRemoved.internalBinaryWrite(message.info.removed, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.Segment
 */
export const Segment = new Segment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionInfo$Type extends MessageType<SessionInfo> {
    constructor() {
        super("sessionsource.SessionInfo", [
            { no: 2, name: "timeCreated", kind: "message", T: () => Timestamp },
            { no: 3, name: "timeFinished", kind: "message", T: () => Timestamp },
            { no: 4, name: "lifetime", kind: "message", T: () => Duration },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "audioFileName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "waveformDataFile", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "keep", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "state", kind: "enum", T: () => ["sessionsource.SessionState", SessionState, "SESSION_STATE_"] },
            { no: 10, name: "segments", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Segment }
        ]);
    }
    create(value?: PartialMessage<SessionInfo>): SessionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.audioFileName = "";
        message.waveformDataFile = "";
        message.keep = false;
        message.state = 0;
        message.segments = [];
        if (value !== undefined)
            reflectionMergePartial<SessionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionInfo): SessionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp timeCreated */ 2:
                    message.timeCreated = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timeCreated);
                    break;
                case /* google.protobuf.Timestamp timeFinished */ 3:
                    message.timeFinished = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.timeFinished);
                    break;
                case /* google.protobuf.Duration lifetime */ 4:
                    message.lifetime = Duration.internalBinaryRead(reader, reader.uint32(), options, message.lifetime);
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* string audioFileName */ 6:
                    message.audioFileName = reader.string();
                    break;
                case /* string waveformDataFile */ 7:
                    message.waveformDataFile = reader.string();
                    break;
                case /* bool keep */ 8:
                    message.keep = reader.bool();
                    break;
                case /* sessionsource.SessionState state */ 9:
                    message.state = reader.int32();
                    break;
                case /* repeated sessionsource.Segment segments */ 10:
                    message.segments.push(Segment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp timeCreated = 2; */
        if (message.timeCreated)
            Timestamp.internalBinaryWrite(message.timeCreated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp timeFinished = 3; */
        if (message.timeFinished)
            Timestamp.internalBinaryWrite(message.timeFinished, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration lifetime = 4; */
        if (message.lifetime)
            Duration.internalBinaryWrite(message.lifetime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* string audioFileName = 6; */
        if (message.audioFileName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.audioFileName);
        /* string waveformDataFile = 7; */
        if (message.waveformDataFile !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.waveformDataFile);
        /* bool keep = 8; */
        if (message.keep !== false)
            writer.tag(8, WireType.Varint).bool(message.keep);
        /* sessionsource.SessionState state = 9; */
        if (message.state !== 0)
            writer.tag(9, WireType.Varint).int32(message.state);
        /* repeated sessionsource.Segment segments = 10; */
        for (let i = 0; i < message.segments.length; i++)
            Segment.internalBinaryWrite(message.segments[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.SessionInfo
 */
export const SessionInfo = new SessionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SessionRemoved$Type extends MessageType<SessionRemoved> {
    constructor() {
        super("sessionsource.SessionRemoved", []);
    }
    create(value?: PartialMessage<SessionRemoved>): SessionRemoved {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SessionRemoved>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionRemoved): SessionRemoved {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionRemoved, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.SessionRemoved
 */
export const SessionRemoved = new SessionRemoved$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Session$Type extends MessageType<Session> {
    constructor() {
        super("sessionsource.Session", [
            { no: 1, name: "ID", kind: "scalar", jsonName: "ID", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "updated", kind: "message", oneof: "info", T: () => SessionInfo },
            { no: 3, name: "removed", kind: "message", oneof: "info", T: () => SessionRemoved }
        ]);
    }
    create(value?: PartialMessage<Session>): Session {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.iD = "";
        message.info = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Session>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Session): Session {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ID */ 1:
                    message.iD = reader.string();
                    break;
                case /* sessionsource.SessionInfo updated */ 2:
                    message.info = {
                        oneofKind: "updated",
                        updated: SessionInfo.internalBinaryRead(reader, reader.uint32(), options, (message.info as any).updated)
                    };
                    break;
                case /* sessionsource.SessionRemoved removed */ 3:
                    message.info = {
                        oneofKind: "removed",
                        removed: SessionRemoved.internalBinaryRead(reader, reader.uint32(), options, (message.info as any).removed)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Session, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ID = 1; */
        if (message.iD !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iD);
        /* sessionsource.SessionInfo updated = 2; */
        if (message.info.oneofKind === "updated")
            SessionInfo.internalBinaryWrite(message.info.updated, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* sessionsource.SessionRemoved removed = 3; */
        if (message.info.oneofKind === "removed")
            SessionRemoved.internalBinaryWrite(message.info.removed, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.Session
 */
export const Session = new Session$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetKeepSessionRequest$Type extends MessageType<SetKeepSessionRequest> {
    constructor() {
        super("sessionsource.SetKeepSessionRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sessionID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "keep", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetKeepSessionRequest>): SetKeepSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        message.sessionID = "";
        message.keep = false;
        if (value !== undefined)
            reflectionMergePartial<SetKeepSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetKeepSessionRequest): SetKeepSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                case /* string sessionID */ 2:
                    message.sessionID = reader.string();
                    break;
                case /* bool keep */ 3:
                    message.keep = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetKeepSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        /* string sessionID = 2; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        /* bool keep = 3; */
        if (message.keep !== false)
            writer.tag(3, WireType.Varint).bool(message.keep);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.SetKeepSessionRequest
 */
export const SetKeepSessionRequest = new SetKeepSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSessionRequest$Type extends MessageType<DeleteSessionRequest> {
    constructor() {
        super("sessionsource.DeleteSessionRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sessionID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteSessionRequest>): DeleteSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        message.sessionID = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSessionRequest): DeleteSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                case /* string sessionID */ 2:
                    message.sessionID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        /* string sessionID = 2; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.DeleteSessionRequest
 */
export const DeleteSessionRequest = new DeleteSessionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetNameRequest$Type extends MessageType<SetNameRequest> {
    constructor() {
        super("sessionsource.SetNameRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sessionID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetNameRequest>): SetNameRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        message.sessionID = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<SetNameRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetNameRequest): SetNameRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                case /* string sessionID */ 2:
                    message.sessionID = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetNameRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        /* string sessionID = 2; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.SetNameRequest
 */
export const SetNameRequest = new SetNameRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSegmentRequest$Type extends MessageType<CreateSegmentRequest> {
    constructor() {
        super("sessionsource.CreateSegmentRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sessionID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "segmentID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "message", T: () => SegmentInfo }
        ]);
    }
    create(value?: PartialMessage<CreateSegmentRequest>): CreateSegmentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        message.sessionID = "";
        message.segmentID = "";
        if (value !== undefined)
            reflectionMergePartial<CreateSegmentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSegmentRequest): CreateSegmentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                case /* string sessionID */ 2:
                    message.sessionID = reader.string();
                    break;
                case /* string segmentID */ 3:
                    message.segmentID = reader.string();
                    break;
                case /* sessionsource.SegmentInfo info */ 4:
                    message.info = SegmentInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSegmentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        /* string sessionID = 2; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        /* string segmentID = 3; */
        if (message.segmentID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.segmentID);
        /* sessionsource.SegmentInfo info = 4; */
        if (message.info)
            SegmentInfo.internalBinaryWrite(message.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.CreateSegmentRequest
 */
export const CreateSegmentRequest = new CreateSegmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateSegmentRequest$Type extends MessageType<UpdateSegmentRequest> {
    constructor() {
        super("sessionsource.UpdateSegmentRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sessionID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "segmentID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "info", kind: "message", T: () => SegmentInfo }
        ]);
    }
    create(value?: PartialMessage<UpdateSegmentRequest>): UpdateSegmentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        message.sessionID = "";
        message.segmentID = "";
        if (value !== undefined)
            reflectionMergePartial<UpdateSegmentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateSegmentRequest): UpdateSegmentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                case /* string sessionID */ 2:
                    message.sessionID = reader.string();
                    break;
                case /* string segmentID */ 3:
                    message.segmentID = reader.string();
                    break;
                case /* sessionsource.SegmentInfo info */ 4:
                    message.info = SegmentInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateSegmentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        /* string sessionID = 2; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        /* string segmentID = 3; */
        if (message.segmentID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.segmentID);
        /* sessionsource.SegmentInfo info = 4; */
        if (message.info)
            SegmentInfo.internalBinaryWrite(message.info, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.UpdateSegmentRequest
 */
export const UpdateSegmentRequest = new UpdateSegmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSegmentRequest$Type extends MessageType<DeleteSegmentRequest> {
    constructor() {
        super("sessionsource.DeleteSegmentRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sessionID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "segmentID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteSegmentRequest>): DeleteSegmentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        message.sessionID = "";
        message.segmentID = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteSegmentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSegmentRequest): DeleteSegmentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                case /* string sessionID */ 2:
                    message.sessionID = reader.string();
                    break;
                case /* string segmentID */ 3:
                    message.segmentID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSegmentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        /* string sessionID = 2; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        /* string segmentID = 3; */
        if (message.segmentID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.segmentID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.DeleteSegmentRequest
 */
export const DeleteSegmentRequest = new DeleteSegmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RenderSegmentRequest$Type extends MessageType<RenderSegmentRequest> {
    constructor() {
        super("sessionsource.RenderSegmentRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "sessionID", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "segmentID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RenderSegmentRequest>): RenderSegmentRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        message.sessionID = "";
        message.segmentID = "";
        if (value !== undefined)
            reflectionMergePartial<RenderSegmentRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RenderSegmentRequest): RenderSegmentRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                case /* string sessionID */ 2:
                    message.sessionID = reader.string();
                    break;
                case /* string segmentID */ 3:
                    message.segmentID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RenderSegmentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        /* string sessionID = 2; */
        if (message.sessionID !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sessionID);
        /* string segmentID = 3; */
        if (message.segmentID !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.segmentID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.RenderSegmentRequest
 */
export const RenderSegmentRequest = new RenderSegmentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CutSessionRequest$Type extends MessageType<CutSessionRequest> {
    constructor() {
        super("sessionsource.CutSessionRequest", [
            { no: 1, name: "recorderID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CutSessionRequest>): CutSessionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.recorderID = "";
        if (value !== undefined)
            reflectionMergePartial<CutSessionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CutSessionRequest): CutSessionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string recorderID */ 1:
                    message.recorderID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CutSessionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string recorderID = 1; */
        if (message.recorderID !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.recorderID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message sessionsource.CutSessionRequest
 */
export const CutSessionRequest = new CutSessionRequest$Type();
/**
 * @generated ServiceType for protobuf service sessionsource.SessionSource
 */
export const SessionSource = new ServiceType("sessionsource.SessionSource", [
    { name: "StreamRecorders", serverStreaming: true, options: {}, I: StreamRecordersRequest, O: Recorder },
    { name: "StreamSessions", serverStreaming: true, options: {}, I: StreamSessionRequest, O: Session },
    { name: "SetKeepSession", options: {}, I: SetKeepSessionRequest, O: Respone },
    { name: "DeleteSession", options: {}, I: DeleteSessionRequest, O: Respone },
    { name: "SetName", options: {}, I: SetNameRequest, O: Respone },
    { name: "CreateSegment", options: {}, I: CreateSegmentRequest, O: Respone },
    { name: "DeleteSegment", options: {}, I: DeleteSegmentRequest, O: Respone },
    { name: "RenderSegment", options: {}, I: RenderSegmentRequest, O: Respone },
    { name: "UpdateSegment", options: {}, I: UpdateSegmentRequest, O: Respone },
    { name: "CutSession", options: {}, I: CutSessionRequest, O: Respone }
]);
