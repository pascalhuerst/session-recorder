// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by protoc --rs_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `sessionsource.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:sessionsource.StreamRecordersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamRecordersRequest {
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.StreamRecordersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamRecordersRequest {
    fn default() -> &'a StreamRecordersRequest {
        <StreamRecordersRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamRecordersRequest {
    pub fn new() -> StreamRecordersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamRecordersRequest>(
            "StreamRecordersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamRecordersRequest {
    const NAME: &'static str = "StreamRecordersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamRecordersRequest {
        StreamRecordersRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamRecordersRequest {
        static instance: StreamRecordersRequest = StreamRecordersRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamRecordersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamRecordersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamRecordersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamRecordersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.RecordereRemoved)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RecordereRemoved {
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.RecordereRemoved.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RecordereRemoved {
    fn default() -> &'a RecordereRemoved {
        <RecordereRemoved as ::protobuf::Message>::default_instance()
    }
}

impl RecordereRemoved {
    pub fn new() -> RecordereRemoved {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RecordereRemoved>(
            "RecordereRemoved",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RecordereRemoved {
    const NAME: &'static str = "RecordereRemoved";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RecordereRemoved {
        RecordereRemoved::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RecordereRemoved {
        static instance: RecordereRemoved = RecordereRemoved {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RecordereRemoved {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RecordereRemoved").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RecordereRemoved {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecordereRemoved {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.Recorder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Recorder {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.Recorder.recorderID)
    pub recorderID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.Recorder.recorderName)
    pub recorderName: ::std::string::String,
    // message oneof groups
    pub info: ::std::option::Option<recorder::Info>,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.Recorder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Recorder {
    fn default() -> &'a Recorder {
        <Recorder as ::protobuf::Message>::default_instance()
    }
}

impl Recorder {
    pub fn new() -> Recorder {
        ::std::default::Default::default()
    }

    // .common.RecorderStatus status = 3;

    pub fn status(&self) -> &super::common::RecorderStatus {
        match self.info {
            ::std::option::Option::Some(recorder::Info::Status(ref v)) => v,
            _ => <super::common::RecorderStatus as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_status(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        match self.info {
            ::std::option::Option::Some(recorder::Info::Status(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::common::RecorderStatus) {
        self.info = ::std::option::Option::Some(recorder::Info::Status(v))
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut super::common::RecorderStatus {
        if let ::std::option::Option::Some(recorder::Info::Status(_)) = self.info {
        } else {
            self.info = ::std::option::Option::Some(recorder::Info::Status(super::common::RecorderStatus::new()));
        }
        match self.info {
            ::std::option::Option::Some(recorder::Info::Status(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_status(&mut self) -> super::common::RecorderStatus {
        if self.has_status() {
            match self.info.take() {
                ::std::option::Option::Some(recorder::Info::Status(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::RecorderStatus::new()
        }
    }

    // .sessionsource.RecordereRemoved removed = 4;

    pub fn removed(&self) -> &RecordereRemoved {
        match self.info {
            ::std::option::Option::Some(recorder::Info::Removed(ref v)) => v,
            _ => <RecordereRemoved as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_removed(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_removed(&self) -> bool {
        match self.info {
            ::std::option::Option::Some(recorder::Info::Removed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_removed(&mut self, v: RecordereRemoved) {
        self.info = ::std::option::Option::Some(recorder::Info::Removed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_removed(&mut self) -> &mut RecordereRemoved {
        if let ::std::option::Option::Some(recorder::Info::Removed(_)) = self.info {
        } else {
            self.info = ::std::option::Option::Some(recorder::Info::Removed(RecordereRemoved::new()));
        }
        match self.info {
            ::std::option::Option::Some(recorder::Info::Removed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_removed(&mut self) -> RecordereRemoved {
        if self.has_removed() {
            match self.info.take() {
                ::std::option::Option::Some(recorder::Info::Removed(v)) => v,
                _ => panic!(),
            }
        } else {
            RecordereRemoved::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &Recorder| { &m.recorderID },
            |m: &mut Recorder| { &mut m.recorderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderName",
            |m: &Recorder| { &m.recorderName },
            |m: &mut Recorder| { &mut m.recorderName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::common::RecorderStatus>(
            "status",
            Recorder::has_status,
            Recorder::status,
            Recorder::mut_status,
            Recorder::set_status,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, RecordereRemoved>(
            "removed",
            Recorder::has_removed,
            Recorder::removed,
            Recorder::mut_removed,
            Recorder::set_removed,
        ));
        oneofs.push(recorder::Info::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Recorder>(
            "Recorder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Recorder {
    const NAME: &'static str = "Recorder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                18 => {
                    self.recorderName = is.read_string()?;
                },
                26 => {
                    self.info = ::std::option::Option::Some(recorder::Info::Status(is.read_message()?));
                },
                34 => {
                    self.info = ::std::option::Option::Some(recorder::Info::Removed(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        if !self.recorderName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.recorderName);
        }
        if let ::std::option::Option::Some(ref v) = self.info {
            match v {
                &recorder::Info::Status(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &recorder::Info::Removed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        if !self.recorderName.is_empty() {
            os.write_string(2, &self.recorderName)?;
        }
        if let ::std::option::Option::Some(ref v) = self.info {
            match v {
                &recorder::Info::Status(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &recorder::Info::Removed(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Recorder {
        Recorder::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.recorderName.clear();
        self.info = ::std::option::Option::None;
        self.info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Recorder {
        static instance: Recorder = Recorder {
            recorderID: ::std::string::String::new(),
            recorderName: ::std::string::String::new(),
            info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Recorder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Recorder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Recorder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Recorder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Recorder`
pub mod recorder {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:sessionsource.Recorder.info)
    pub enum Info {
        // @@protoc_insertion_point(oneof_field:sessionsource.Recorder.status)
        Status(super::super::common::RecorderStatus),
        // @@protoc_insertion_point(oneof_field:sessionsource.Recorder.removed)
        Removed(super::RecordereRemoved),
    }

    impl ::protobuf::Oneof for Info {
    }

    impl ::protobuf::OneofFull for Info {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Recorder as ::protobuf::MessageFull>::descriptor().oneof_by_name("info").unwrap()).clone()
        }
    }

    impl Info {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Info>("info")
        }
    }
}

// @@protoc_insertion_point(message:sessionsource.StreamSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StreamSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.StreamSessionRequest.recorderID)
    pub recorderID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.StreamSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamSessionRequest {
    fn default() -> &'a StreamSessionRequest {
        <StreamSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamSessionRequest {
    pub fn new() -> StreamSessionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &StreamSessionRequest| { &m.recorderID },
            |m: &mut StreamSessionRequest| { &mut m.recorderID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamSessionRequest>(
            "StreamSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamSessionRequest {
    const NAME: &'static str = "StreamSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamSessionRequest {
        StreamSessionRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamSessionRequest {
        static instance: StreamSessionRequest = StreamSessionRequest {
            recorderID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.SegmentInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SegmentInfo {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.SegmentInfo.timeStart)
    pub timeStart: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:sessionsource.SegmentInfo.timeEnd)
    pub timeEnd: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:sessionsource.SegmentInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.SegmentInfo.state)
    pub state: ::protobuf::EnumOrUnknown<SegmentState>,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.SegmentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SegmentInfo {
    fn default() -> &'a SegmentInfo {
        <SegmentInfo as ::protobuf::Message>::default_instance()
    }
}

impl SegmentInfo {
    pub fn new() -> SegmentInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timeStart",
            |m: &SegmentInfo| { &m.timeStart },
            |m: &mut SegmentInfo| { &mut m.timeStart },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timeEnd",
            |m: &SegmentInfo| { &m.timeEnd },
            |m: &mut SegmentInfo| { &mut m.timeEnd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SegmentInfo| { &m.name },
            |m: &mut SegmentInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SegmentInfo| { &m.state },
            |m: &mut SegmentInfo| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SegmentInfo>(
            "SegmentInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SegmentInfo {
    const NAME: &'static str = "SegmentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeStart)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeEnd)?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                32 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timeStart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timeEnd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.state != ::protobuf::EnumOrUnknown::new(SegmentState::SEGMENT_STATE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.state.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timeStart.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.timeEnd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(SegmentState::SEGMENT_STATE_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SegmentInfo {
        SegmentInfo::new()
    }

    fn clear(&mut self) {
        self.timeStart.clear();
        self.timeEnd.clear();
        self.name.clear();
        self.state = ::protobuf::EnumOrUnknown::new(SegmentState::SEGMENT_STATE_UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SegmentInfo {
        static instance: SegmentInfo = SegmentInfo {
            timeStart: ::protobuf::MessageField::none(),
            timeEnd: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SegmentInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SegmentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SegmentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SegmentInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.SegmentRemoved)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SegmentRemoved {
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.SegmentRemoved.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SegmentRemoved {
    fn default() -> &'a SegmentRemoved {
        <SegmentRemoved as ::protobuf::Message>::default_instance()
    }
}

impl SegmentRemoved {
    pub fn new() -> SegmentRemoved {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SegmentRemoved>(
            "SegmentRemoved",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SegmentRemoved {
    const NAME: &'static str = "SegmentRemoved";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SegmentRemoved {
        SegmentRemoved::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SegmentRemoved {
        static instance: SegmentRemoved = SegmentRemoved {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SegmentRemoved {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SegmentRemoved").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SegmentRemoved {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SegmentRemoved {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.Segment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Segment {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.Segment.segmentID)
    pub segmentID: ::std::string::String,
    // message oneof groups
    pub info: ::std::option::Option<segment::Info>,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.Segment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Segment {
    fn default() -> &'a Segment {
        <Segment as ::protobuf::Message>::default_instance()
    }
}

impl Segment {
    pub fn new() -> Segment {
        ::std::default::Default::default()
    }

    // .sessionsource.SegmentInfo updated = 2;

    pub fn updated(&self) -> &SegmentInfo {
        match self.info {
            ::std::option::Option::Some(segment::Info::Updated(ref v)) => v,
            _ => <SegmentInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_updated(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_updated(&self) -> bool {
        match self.info {
            ::std::option::Option::Some(segment::Info::Updated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: SegmentInfo) {
        self.info = ::std::option::Option::Some(segment::Info::Updated(v))
    }

    // Mutable pointer to the field.
    pub fn mut_updated(&mut self) -> &mut SegmentInfo {
        if let ::std::option::Option::Some(segment::Info::Updated(_)) = self.info {
        } else {
            self.info = ::std::option::Option::Some(segment::Info::Updated(SegmentInfo::new()));
        }
        match self.info {
            ::std::option::Option::Some(segment::Info::Updated(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_updated(&mut self) -> SegmentInfo {
        if self.has_updated() {
            match self.info.take() {
                ::std::option::Option::Some(segment::Info::Updated(v)) => v,
                _ => panic!(),
            }
        } else {
            SegmentInfo::new()
        }
    }

    // .sessionsource.SegmentRemoved removed = 3;

    pub fn removed(&self) -> &SegmentRemoved {
        match self.info {
            ::std::option::Option::Some(segment::Info::Removed(ref v)) => v,
            _ => <SegmentRemoved as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_removed(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_removed(&self) -> bool {
        match self.info {
            ::std::option::Option::Some(segment::Info::Removed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_removed(&mut self, v: SegmentRemoved) {
        self.info = ::std::option::Option::Some(segment::Info::Removed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_removed(&mut self) -> &mut SegmentRemoved {
        if let ::std::option::Option::Some(segment::Info::Removed(_)) = self.info {
        } else {
            self.info = ::std::option::Option::Some(segment::Info::Removed(SegmentRemoved::new()));
        }
        match self.info {
            ::std::option::Option::Some(segment::Info::Removed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_removed(&mut self) -> SegmentRemoved {
        if self.has_removed() {
            match self.info.take() {
                ::std::option::Option::Some(segment::Info::Removed(v)) => v,
                _ => panic!(),
            }
        } else {
            SegmentRemoved::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "segmentID",
            |m: &Segment| { &m.segmentID },
            |m: &mut Segment| { &mut m.segmentID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SegmentInfo>(
            "updated",
            Segment::has_updated,
            Segment::updated,
            Segment::mut_updated,
            Segment::set_updated,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SegmentRemoved>(
            "removed",
            Segment::has_removed,
            Segment::removed,
            Segment::mut_removed,
            Segment::set_removed,
        ));
        oneofs.push(segment::Info::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Segment>(
            "Segment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Segment {
    const NAME: &'static str = "Segment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.segmentID = is.read_string()?;
                },
                18 => {
                    self.info = ::std::option::Option::Some(segment::Info::Updated(is.read_message()?));
                },
                26 => {
                    self.info = ::std::option::Option::Some(segment::Info::Removed(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.segmentID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.segmentID);
        }
        if let ::std::option::Option::Some(ref v) = self.info {
            match v {
                &segment::Info::Updated(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &segment::Info::Removed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.segmentID.is_empty() {
            os.write_string(1, &self.segmentID)?;
        }
        if let ::std::option::Option::Some(ref v) = self.info {
            match v {
                &segment::Info::Updated(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &segment::Info::Removed(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Segment {
        Segment::new()
    }

    fn clear(&mut self) {
        self.segmentID.clear();
        self.info = ::std::option::Option::None;
        self.info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Segment {
        static instance: Segment = Segment {
            segmentID: ::std::string::String::new(),
            info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Segment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Segment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Segment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Segment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Segment`
pub mod segment {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:sessionsource.Segment.info)
    pub enum Info {
        // @@protoc_insertion_point(oneof_field:sessionsource.Segment.updated)
        Updated(super::SegmentInfo),
        // @@protoc_insertion_point(oneof_field:sessionsource.Segment.removed)
        Removed(super::SegmentRemoved),
    }

    impl ::protobuf::Oneof for Info {
    }

    impl ::protobuf::OneofFull for Info {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Segment as ::protobuf::MessageFull>::descriptor().oneof_by_name("info").unwrap()).clone()
        }
    }

    impl Info {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Info>("info")
        }
    }
}

// @@protoc_insertion_point(message:sessionsource.SessionInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SessionInfo {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.timeCreated)
    pub timeCreated: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.timeFinished)
    pub timeFinished: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.lifetime)
    pub lifetime: ::protobuf::MessageField<::protobuf::well_known_types::duration::Duration>,
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.audioFileName)
    pub audioFileName: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.waveformDataFile)
    pub waveformDataFile: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.keep)
    pub keep: bool,
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.state)
    pub state: ::protobuf::EnumOrUnknown<SessionState>,
    // @@protoc_insertion_point(field:sessionsource.SessionInfo.segments)
    pub segments: ::std::vec::Vec<Segment>,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.SessionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SessionInfo {
    fn default() -> &'a SessionInfo {
        <SessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl SessionInfo {
    pub fn new() -> SessionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timeCreated",
            |m: &SessionInfo| { &m.timeCreated },
            |m: &mut SessionInfo| { &mut m.timeCreated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timeFinished",
            |m: &SessionInfo| { &m.timeFinished },
            |m: &mut SessionInfo| { &mut m.timeFinished },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::duration::Duration>(
            "lifetime",
            |m: &SessionInfo| { &m.lifetime },
            |m: &mut SessionInfo| { &mut m.lifetime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SessionInfo| { &m.name },
            |m: &mut SessionInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "audioFileName",
            |m: &SessionInfo| { &m.audioFileName },
            |m: &mut SessionInfo| { &mut m.audioFileName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "waveformDataFile",
            |m: &SessionInfo| { &m.waveformDataFile },
            |m: &mut SessionInfo| { &mut m.waveformDataFile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "keep",
            |m: &SessionInfo| { &m.keep },
            |m: &mut SessionInfo| { &mut m.keep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SessionInfo| { &m.state },
            |m: &mut SessionInfo| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "segments",
            |m: &SessionInfo| { &m.segments },
            |m: &mut SessionInfo| { &mut m.segments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SessionInfo>(
            "SessionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SessionInfo {
    const NAME: &'static str = "SessionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeCreated)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timeFinished)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lifetime)?;
                },
                42 => {
                    self.name = is.read_string()?;
                },
                50 => {
                    self.audioFileName = is.read_string()?;
                },
                58 => {
                    self.waveformDataFile = is.read_string()?;
                },
                64 => {
                    self.keep = is.read_bool()?;
                },
                72 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                82 => {
                    self.segments.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timeCreated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timeFinished.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lifetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        if !self.audioFileName.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.audioFileName);
        }
        if !self.waveformDataFile.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.waveformDataFile);
        }
        if self.keep != false {
            my_size += 1 + 1;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(SessionState::SESSION_STATE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(9, self.state.value());
        }
        for value in &self.segments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timeCreated.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.timeFinished.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.lifetime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        if !self.audioFileName.is_empty() {
            os.write_string(6, &self.audioFileName)?;
        }
        if !self.waveformDataFile.is_empty() {
            os.write_string(7, &self.waveformDataFile)?;
        }
        if self.keep != false {
            os.write_bool(8, self.keep)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(SessionState::SESSION_STATE_UNKNOWN) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        for v in &self.segments {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SessionInfo {
        SessionInfo::new()
    }

    fn clear(&mut self) {
        self.timeCreated.clear();
        self.timeFinished.clear();
        self.lifetime.clear();
        self.name.clear();
        self.audioFileName.clear();
        self.waveformDataFile.clear();
        self.keep = false;
        self.state = ::protobuf::EnumOrUnknown::new(SessionState::SESSION_STATE_UNKNOWN);
        self.segments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SessionInfo {
        static instance: SessionInfo = SessionInfo {
            timeCreated: ::protobuf::MessageField::none(),
            timeFinished: ::protobuf::MessageField::none(),
            lifetime: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            audioFileName: ::std::string::String::new(),
            waveformDataFile: ::std::string::String::new(),
            keep: false,
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            segments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SessionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SessionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SessionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.SessionRemoved)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SessionRemoved {
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.SessionRemoved.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SessionRemoved {
    fn default() -> &'a SessionRemoved {
        <SessionRemoved as ::protobuf::Message>::default_instance()
    }
}

impl SessionRemoved {
    pub fn new() -> SessionRemoved {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SessionRemoved>(
            "SessionRemoved",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SessionRemoved {
    const NAME: &'static str = "SessionRemoved";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SessionRemoved {
        SessionRemoved::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SessionRemoved {
        static instance: SessionRemoved = SessionRemoved {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SessionRemoved {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SessionRemoved").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SessionRemoved {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionRemoved {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.Session)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Session {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.Session.ID)
    pub ID: ::std::string::String,
    // message oneof groups
    pub info: ::std::option::Option<session::Info>,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.Session.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Session {
    fn default() -> &'a Session {
        <Session as ::protobuf::Message>::default_instance()
    }
}

impl Session {
    pub fn new() -> Session {
        ::std::default::Default::default()
    }

    // .sessionsource.SessionInfo updated = 2;

    pub fn updated(&self) -> &SessionInfo {
        match self.info {
            ::std::option::Option::Some(session::Info::Updated(ref v)) => v,
            _ => <SessionInfo as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_updated(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_updated(&self) -> bool {
        match self.info {
            ::std::option::Option::Some(session::Info::Updated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_updated(&mut self, v: SessionInfo) {
        self.info = ::std::option::Option::Some(session::Info::Updated(v))
    }

    // Mutable pointer to the field.
    pub fn mut_updated(&mut self) -> &mut SessionInfo {
        if let ::std::option::Option::Some(session::Info::Updated(_)) = self.info {
        } else {
            self.info = ::std::option::Option::Some(session::Info::Updated(SessionInfo::new()));
        }
        match self.info {
            ::std::option::Option::Some(session::Info::Updated(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_updated(&mut self) -> SessionInfo {
        if self.has_updated() {
            match self.info.take() {
                ::std::option::Option::Some(session::Info::Updated(v)) => v,
                _ => panic!(),
            }
        } else {
            SessionInfo::new()
        }
    }

    // .sessionsource.SessionRemoved removed = 3;

    pub fn removed(&self) -> &SessionRemoved {
        match self.info {
            ::std::option::Option::Some(session::Info::Removed(ref v)) => v,
            _ => <SessionRemoved as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_removed(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_removed(&self) -> bool {
        match self.info {
            ::std::option::Option::Some(session::Info::Removed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_removed(&mut self, v: SessionRemoved) {
        self.info = ::std::option::Option::Some(session::Info::Removed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_removed(&mut self) -> &mut SessionRemoved {
        if let ::std::option::Option::Some(session::Info::Removed(_)) = self.info {
        } else {
            self.info = ::std::option::Option::Some(session::Info::Removed(SessionRemoved::new()));
        }
        match self.info {
            ::std::option::Option::Some(session::Info::Removed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_removed(&mut self) -> SessionRemoved {
        if self.has_removed() {
            match self.info.take() {
                ::std::option::Option::Some(session::Info::Removed(v)) => v,
                _ => panic!(),
            }
        } else {
            SessionRemoved::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ID",
            |m: &Session| { &m.ID },
            |m: &mut Session| { &mut m.ID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SessionInfo>(
            "updated",
            Session::has_updated,
            Session::updated,
            Session::mut_updated,
            Session::set_updated,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, SessionRemoved>(
            "removed",
            Session::has_removed,
            Session::removed,
            Session::mut_removed,
            Session::set_removed,
        ));
        oneofs.push(session::Info::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Session>(
            "Session",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Session {
    const NAME: &'static str = "Session";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ID = is.read_string()?;
                },
                18 => {
                    self.info = ::std::option::Option::Some(session::Info::Updated(is.read_message()?));
                },
                26 => {
                    self.info = ::std::option::Option::Some(session::Info::Removed(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.ID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ID);
        }
        if let ::std::option::Option::Some(ref v) = self.info {
            match v {
                &session::Info::Updated(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &session::Info::Removed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.ID.is_empty() {
            os.write_string(1, &self.ID)?;
        }
        if let ::std::option::Option::Some(ref v) = self.info {
            match v {
                &session::Info::Updated(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &session::Info::Removed(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Session {
        Session::new()
    }

    fn clear(&mut self) {
        self.ID.clear();
        self.info = ::std::option::Option::None;
        self.info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Session {
        static instance: Session = Session {
            ID: ::std::string::String::new(),
            info: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Session {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Session").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Session {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Session {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Session`
pub mod session {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:sessionsource.Session.info)
    pub enum Info {
        // @@protoc_insertion_point(oneof_field:sessionsource.Session.updated)
        Updated(super::SessionInfo),
        // @@protoc_insertion_point(oneof_field:sessionsource.Session.removed)
        Removed(super::SessionRemoved),
    }

    impl ::protobuf::Oneof for Info {
    }

    impl ::protobuf::OneofFull for Info {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Session as ::protobuf::MessageFull>::descriptor().oneof_by_name("info").unwrap()).clone()
        }
    }

    impl Info {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Info>("info")
        }
    }
}

// @@protoc_insertion_point(message:sessionsource.SetKeepSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetKeepSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.SetKeepSessionRequest.recorderID)
    pub recorderID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.SetKeepSessionRequest.sessionID)
    pub sessionID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.SetKeepSessionRequest.keep)
    pub keep: bool,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.SetKeepSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetKeepSessionRequest {
    fn default() -> &'a SetKeepSessionRequest {
        <SetKeepSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetKeepSessionRequest {
    pub fn new() -> SetKeepSessionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &SetKeepSessionRequest| { &m.recorderID },
            |m: &mut SetKeepSessionRequest| { &mut m.recorderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sessionID",
            |m: &SetKeepSessionRequest| { &m.sessionID },
            |m: &mut SetKeepSessionRequest| { &mut m.sessionID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "keep",
            |m: &SetKeepSessionRequest| { &m.keep },
            |m: &mut SetKeepSessionRequest| { &mut m.keep },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetKeepSessionRequest>(
            "SetKeepSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetKeepSessionRequest {
    const NAME: &'static str = "SetKeepSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                18 => {
                    self.sessionID = is.read_string()?;
                },
                24 => {
                    self.keep = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        if !self.sessionID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sessionID);
        }
        if self.keep != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        if !self.sessionID.is_empty() {
            os.write_string(2, &self.sessionID)?;
        }
        if self.keep != false {
            os.write_bool(3, self.keep)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetKeepSessionRequest {
        SetKeepSessionRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.sessionID.clear();
        self.keep = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetKeepSessionRequest {
        static instance: SetKeepSessionRequest = SetKeepSessionRequest {
            recorderID: ::std::string::String::new(),
            sessionID: ::std::string::String::new(),
            keep: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetKeepSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetKeepSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetKeepSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetKeepSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.DeleteSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.DeleteSessionRequest.recorderID)
    pub recorderID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.DeleteSessionRequest.sessionID)
    pub sessionID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.DeleteSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSessionRequest {
    fn default() -> &'a DeleteSessionRequest {
        <DeleteSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSessionRequest {
    pub fn new() -> DeleteSessionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &DeleteSessionRequest| { &m.recorderID },
            |m: &mut DeleteSessionRequest| { &mut m.recorderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sessionID",
            |m: &DeleteSessionRequest| { &m.sessionID },
            |m: &mut DeleteSessionRequest| { &mut m.sessionID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSessionRequest>(
            "DeleteSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSessionRequest {
    const NAME: &'static str = "DeleteSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                18 => {
                    self.sessionID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        if !self.sessionID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sessionID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        if !self.sessionID.is_empty() {
            os.write_string(2, &self.sessionID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSessionRequest {
        DeleteSessionRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.sessionID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSessionRequest {
        static instance: DeleteSessionRequest = DeleteSessionRequest {
            recorderID: ::std::string::String::new(),
            sessionID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.SetNameRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SetNameRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.SetNameRequest.recorderID)
    pub recorderID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.SetNameRequest.sessionID)
    pub sessionID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.SetNameRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.SetNameRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SetNameRequest {
    fn default() -> &'a SetNameRequest {
        <SetNameRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetNameRequest {
    pub fn new() -> SetNameRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &SetNameRequest| { &m.recorderID },
            |m: &mut SetNameRequest| { &mut m.recorderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sessionID",
            |m: &SetNameRequest| { &m.sessionID },
            |m: &mut SetNameRequest| { &mut m.sessionID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &SetNameRequest| { &m.name },
            |m: &mut SetNameRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetNameRequest>(
            "SetNameRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SetNameRequest {
    const NAME: &'static str = "SetNameRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                18 => {
                    self.sessionID = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        if !self.sessionID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sessionID);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        if !self.sessionID.is_empty() {
            os.write_string(2, &self.sessionID)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SetNameRequest {
        SetNameRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.sessionID.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SetNameRequest {
        static instance: SetNameRequest = SetNameRequest {
            recorderID: ::std::string::String::new(),
            sessionID: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SetNameRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SetNameRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SetNameRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetNameRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.CreateSegmentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateSegmentRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.CreateSegmentRequest.recorderID)
    pub recorderID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.CreateSegmentRequest.sessionID)
    pub sessionID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.CreateSegmentRequest.segmentID)
    pub segmentID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.CreateSegmentRequest.info)
    pub info: ::protobuf::MessageField<SegmentInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.CreateSegmentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateSegmentRequest {
    fn default() -> &'a CreateSegmentRequest {
        <CreateSegmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSegmentRequest {
    pub fn new() -> CreateSegmentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &CreateSegmentRequest| { &m.recorderID },
            |m: &mut CreateSegmentRequest| { &mut m.recorderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sessionID",
            |m: &CreateSegmentRequest| { &m.sessionID },
            |m: &mut CreateSegmentRequest| { &mut m.sessionID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "segmentID",
            |m: &CreateSegmentRequest| { &m.segmentID },
            |m: &mut CreateSegmentRequest| { &mut m.segmentID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SegmentInfo>(
            "info",
            |m: &CreateSegmentRequest| { &m.info },
            |m: &mut CreateSegmentRequest| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateSegmentRequest>(
            "CreateSegmentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateSegmentRequest {
    const NAME: &'static str = "CreateSegmentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                18 => {
                    self.sessionID = is.read_string()?;
                },
                26 => {
                    self.segmentID = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        if !self.sessionID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sessionID);
        }
        if !self.segmentID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.segmentID);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        if !self.sessionID.is_empty() {
            os.write_string(2, &self.sessionID)?;
        }
        if !self.segmentID.is_empty() {
            os.write_string(3, &self.segmentID)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateSegmentRequest {
        CreateSegmentRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.sessionID.clear();
        self.segmentID.clear();
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateSegmentRequest {
        static instance: CreateSegmentRequest = CreateSegmentRequest {
            recorderID: ::std::string::String::new(),
            sessionID: ::std::string::String::new(),
            segmentID: ::std::string::String::new(),
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateSegmentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateSegmentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateSegmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSegmentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.UpdateSegmentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateSegmentRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.UpdateSegmentRequest.recorderID)
    pub recorderID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.UpdateSegmentRequest.sessionID)
    pub sessionID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.UpdateSegmentRequest.segmentID)
    pub segmentID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.UpdateSegmentRequest.info)
    pub info: ::protobuf::MessageField<SegmentInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.UpdateSegmentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateSegmentRequest {
    fn default() -> &'a UpdateSegmentRequest {
        <UpdateSegmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSegmentRequest {
    pub fn new() -> UpdateSegmentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &UpdateSegmentRequest| { &m.recorderID },
            |m: &mut UpdateSegmentRequest| { &mut m.recorderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sessionID",
            |m: &UpdateSegmentRequest| { &m.sessionID },
            |m: &mut UpdateSegmentRequest| { &mut m.sessionID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "segmentID",
            |m: &UpdateSegmentRequest| { &m.segmentID },
            |m: &mut UpdateSegmentRequest| { &mut m.segmentID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SegmentInfo>(
            "info",
            |m: &UpdateSegmentRequest| { &m.info },
            |m: &mut UpdateSegmentRequest| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateSegmentRequest>(
            "UpdateSegmentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateSegmentRequest {
    const NAME: &'static str = "UpdateSegmentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                18 => {
                    self.sessionID = is.read_string()?;
                },
                26 => {
                    self.segmentID = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        if !self.sessionID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sessionID);
        }
        if !self.segmentID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.segmentID);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        if !self.sessionID.is_empty() {
            os.write_string(2, &self.sessionID)?;
        }
        if !self.segmentID.is_empty() {
            os.write_string(3, &self.segmentID)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateSegmentRequest {
        UpdateSegmentRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.sessionID.clear();
        self.segmentID.clear();
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateSegmentRequest {
        static instance: UpdateSegmentRequest = UpdateSegmentRequest {
            recorderID: ::std::string::String::new(),
            sessionID: ::std::string::String::new(),
            segmentID: ::std::string::String::new(),
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateSegmentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateSegmentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateSegmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSegmentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.DeleteSegmentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeleteSegmentRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.DeleteSegmentRequest.recorderID)
    pub recorderID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.DeleteSegmentRequest.sessionID)
    pub sessionID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.DeleteSegmentRequest.segmentID)
    pub segmentID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.DeleteSegmentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteSegmentRequest {
    fn default() -> &'a DeleteSegmentRequest {
        <DeleteSegmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteSegmentRequest {
    pub fn new() -> DeleteSegmentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &DeleteSegmentRequest| { &m.recorderID },
            |m: &mut DeleteSegmentRequest| { &mut m.recorderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sessionID",
            |m: &DeleteSegmentRequest| { &m.sessionID },
            |m: &mut DeleteSegmentRequest| { &mut m.sessionID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "segmentID",
            |m: &DeleteSegmentRequest| { &m.segmentID },
            |m: &mut DeleteSegmentRequest| { &mut m.segmentID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteSegmentRequest>(
            "DeleteSegmentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteSegmentRequest {
    const NAME: &'static str = "DeleteSegmentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                18 => {
                    self.sessionID = is.read_string()?;
                },
                26 => {
                    self.segmentID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        if !self.sessionID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sessionID);
        }
        if !self.segmentID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.segmentID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        if !self.sessionID.is_empty() {
            os.write_string(2, &self.sessionID)?;
        }
        if !self.segmentID.is_empty() {
            os.write_string(3, &self.segmentID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteSegmentRequest {
        DeleteSegmentRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.sessionID.clear();
        self.segmentID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteSegmentRequest {
        static instance: DeleteSegmentRequest = DeleteSegmentRequest {
            recorderID: ::std::string::String::new(),
            sessionID: ::std::string::String::new(),
            segmentID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteSegmentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteSegmentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteSegmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteSegmentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.RenderSegmentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RenderSegmentRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.RenderSegmentRequest.recorderID)
    pub recorderID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.RenderSegmentRequest.sessionID)
    pub sessionID: ::std::string::String,
    // @@protoc_insertion_point(field:sessionsource.RenderSegmentRequest.segmentID)
    pub segmentID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.RenderSegmentRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RenderSegmentRequest {
    fn default() -> &'a RenderSegmentRequest {
        <RenderSegmentRequest as ::protobuf::Message>::default_instance()
    }
}

impl RenderSegmentRequest {
    pub fn new() -> RenderSegmentRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &RenderSegmentRequest| { &m.recorderID },
            |m: &mut RenderSegmentRequest| { &mut m.recorderID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sessionID",
            |m: &RenderSegmentRequest| { &m.sessionID },
            |m: &mut RenderSegmentRequest| { &mut m.sessionID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "segmentID",
            |m: &RenderSegmentRequest| { &m.segmentID },
            |m: &mut RenderSegmentRequest| { &mut m.segmentID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RenderSegmentRequest>(
            "RenderSegmentRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RenderSegmentRequest {
    const NAME: &'static str = "RenderSegmentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                18 => {
                    self.sessionID = is.read_string()?;
                },
                26 => {
                    self.segmentID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        if !self.sessionID.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sessionID);
        }
        if !self.segmentID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.segmentID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        if !self.sessionID.is_empty() {
            os.write_string(2, &self.sessionID)?;
        }
        if !self.segmentID.is_empty() {
            os.write_string(3, &self.segmentID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RenderSegmentRequest {
        RenderSegmentRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.sessionID.clear();
        self.segmentID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RenderSegmentRequest {
        static instance: RenderSegmentRequest = RenderSegmentRequest {
            recorderID: ::std::string::String::new(),
            sessionID: ::std::string::String::new(),
            segmentID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RenderSegmentRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RenderSegmentRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RenderSegmentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RenderSegmentRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:sessionsource.CutSessionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CutSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:sessionsource.CutSessionRequest.recorderID)
    pub recorderID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:sessionsource.CutSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CutSessionRequest {
    fn default() -> &'a CutSessionRequest {
        <CutSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CutSessionRequest {
    pub fn new() -> CutSessionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recorderID",
            |m: &CutSessionRequest| { &m.recorderID },
            |m: &mut CutSessionRequest| { &mut m.recorderID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CutSessionRequest>(
            "CutSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CutSessionRequest {
    const NAME: &'static str = "CutSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recorderID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recorderID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recorderID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recorderID.is_empty() {
            os.write_string(1, &self.recorderID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CutSessionRequest {
        CutSessionRequest::new()
    }

    fn clear(&mut self) {
        self.recorderID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CutSessionRequest {
        static instance: CutSessionRequest = CutSessionRequest {
            recorderID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CutSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CutSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CutSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CutSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:sessionsource.SegmentState)
pub enum SegmentState {
    // @@protoc_insertion_point(enum_value:sessionsource.SegmentState.SEGMENT_STATE_UNKNOWN)
    SEGMENT_STATE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:sessionsource.SegmentState.SEGMENT_STATE_RENDERING)
    SEGMENT_STATE_RENDERING = 1,
    // @@protoc_insertion_point(enum_value:sessionsource.SegmentState.SEGMENT_STATE_FINISHED)
    SEGMENT_STATE_FINISHED = 2,
    // @@protoc_insertion_point(enum_value:sessionsource.SegmentState.SEGMENT_STATE_ERROR)
    SEGMENT_STATE_ERROR = 3,
}

impl ::protobuf::Enum for SegmentState {
    const NAME: &'static str = "SegmentState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SegmentState> {
        match value {
            0 => ::std::option::Option::Some(SegmentState::SEGMENT_STATE_UNKNOWN),
            1 => ::std::option::Option::Some(SegmentState::SEGMENT_STATE_RENDERING),
            2 => ::std::option::Option::Some(SegmentState::SEGMENT_STATE_FINISHED),
            3 => ::std::option::Option::Some(SegmentState::SEGMENT_STATE_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SegmentState> {
        match str {
            "SEGMENT_STATE_UNKNOWN" => ::std::option::Option::Some(SegmentState::SEGMENT_STATE_UNKNOWN),
            "SEGMENT_STATE_RENDERING" => ::std::option::Option::Some(SegmentState::SEGMENT_STATE_RENDERING),
            "SEGMENT_STATE_FINISHED" => ::std::option::Option::Some(SegmentState::SEGMENT_STATE_FINISHED),
            "SEGMENT_STATE_ERROR" => ::std::option::Option::Some(SegmentState::SEGMENT_STATE_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SegmentState] = &[
        SegmentState::SEGMENT_STATE_UNKNOWN,
        SegmentState::SEGMENT_STATE_RENDERING,
        SegmentState::SEGMENT_STATE_FINISHED,
        SegmentState::SEGMENT_STATE_ERROR,
    ];
}

impl ::protobuf::EnumFull for SegmentState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SegmentState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SegmentState {
    fn default() -> Self {
        SegmentState::SEGMENT_STATE_UNKNOWN
    }
}

impl SegmentState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SegmentState>("SegmentState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:sessionsource.SessionState)
pub enum SessionState {
    // @@protoc_insertion_point(enum_value:sessionsource.SessionState.SESSION_STATE_UNKNOWN)
    SESSION_STATE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:sessionsource.SessionState.SESSION_STATE_RECORDING)
    SESSION_STATE_RECORDING = 1,
    // @@protoc_insertion_point(enum_value:sessionsource.SessionState.SESSION_STATE_FINISHED)
    SESSION_STATE_FINISHED = 2,
}

impl ::protobuf::Enum for SessionState {
    const NAME: &'static str = "SessionState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SessionState> {
        match value {
            0 => ::std::option::Option::Some(SessionState::SESSION_STATE_UNKNOWN),
            1 => ::std::option::Option::Some(SessionState::SESSION_STATE_RECORDING),
            2 => ::std::option::Option::Some(SessionState::SESSION_STATE_FINISHED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SessionState> {
        match str {
            "SESSION_STATE_UNKNOWN" => ::std::option::Option::Some(SessionState::SESSION_STATE_UNKNOWN),
            "SESSION_STATE_RECORDING" => ::std::option::Option::Some(SessionState::SESSION_STATE_RECORDING),
            "SESSION_STATE_FINISHED" => ::std::option::Option::Some(SessionState::SESSION_STATE_FINISHED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SessionState] = &[
        SessionState::SESSION_STATE_UNKNOWN,
        SessionState::SESSION_STATE_RECORDING,
        SessionState::SESSION_STATE_FINISHED,
    ];
}

impl ::protobuf::EnumFull for SessionState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SessionState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SessionState {
    fn default() -> Self {
        SessionState::SESSION_STATE_UNKNOWN
    }
}

impl SessionState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SessionState>("SessionState")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13sessionsource.proto\x12\rsessionsource\x1a\x0ccommon.proto\x1a\x1f\
    google/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/duration.proto\"\
    \x18\n\x16StreamRecordersRequest\"\x12\n\x10RecordereRemoved\"\xc5\x01\n\
    \x08Recorder\x12\x1e\n\nrecorderID\x18\x01\x20\x01(\tR\nrecorderID\x12\"\
    \n\x0crecorderName\x18\x02\x20\x01(\tR\x0crecorderName\x120\n\x06status\
    \x18\x03\x20\x01(\x0b2\x16.common.RecorderStatusH\0R\x06status\x12;\n\
    \x07removed\x18\x04\x20\x01(\x0b2\x1f.sessionsource.RecordereRemovedH\0R\
    \x07removedB\x06\n\x04info\"6\n\x14StreamSessionRequest\x12\x1e\n\nrecor\
    derID\x18\x01\x20\x01(\tR\nrecorderID\"\xc4\x01\n\x0bSegmentInfo\x128\n\
    \ttimeStart\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ttimeSt\
    art\x124\n\x07timeEnd\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Timestam\
    pR\x07timeEnd\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x121\n\x05st\
    ate\x18\x04\x20\x01(\x0e2\x1b.sessionsource.SegmentStateR\x05state\"\x10\
    \n\x0eSegmentRemoved\"\xa2\x01\n\x07Segment\x12\x1c\n\tsegmentID\x18\x01\
    \x20\x01(\tR\tsegmentID\x126\n\x07updated\x18\x02\x20\x01(\x0b2\x1a.sess\
    ionsource.SegmentInfoH\0R\x07updated\x129\n\x07removed\x18\x03\x20\x01(\
    \x0b2\x1d.sessionsource.SegmentRemovedH\0R\x07removedB\x06\n\x04info\"\
    \xa3\x03\n\x0bSessionInfo\x12<\n\x0btimeCreated\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x0btimeCreated\x12>\n\x0ctimeFinished\
    \x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0ctimeFinished\
    \x125\n\x08lifetime\x18\x04\x20\x01(\x0b2\x19.google.protobuf.DurationR\
    \x08lifetime\x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04name\x12$\n\raudio\
    FileName\x18\x06\x20\x01(\tR\raudioFileName\x12*\n\x10waveformDataFile\
    \x18\x07\x20\x01(\tR\x10waveformDataFile\x12\x12\n\x04keep\x18\x08\x20\
    \x01(\x08R\x04keep\x121\n\x05state\x18\t\x20\x01(\x0e2\x1b.sessionsource\
    .SessionStateR\x05state\x122\n\x08segments\x18\n\x20\x03(\x0b2\x16.sessi\
    onsource.SegmentR\x08segments\"\x10\n\x0eSessionRemoved\"\x94\x01\n\x07S\
    ession\x12\x0e\n\x02ID\x18\x01\x20\x01(\tR\x02ID\x126\n\x07updated\x18\
    \x02\x20\x01(\x0b2\x1a.sessionsource.SessionInfoH\0R\x07updated\x129\n\
    \x07removed\x18\x03\x20\x01(\x0b2\x1d.sessionsource.SessionRemovedH\0R\
    \x07removedB\x06\n\x04info\"i\n\x15SetKeepSessionRequest\x12\x1e\n\nreco\
    rderID\x18\x01\x20\x01(\tR\nrecorderID\x12\x1c\n\tsessionID\x18\x02\x20\
    \x01(\tR\tsessionID\x12\x12\n\x04keep\x18\x03\x20\x01(\x08R\x04keep\"T\n\
    \x14DeleteSessionRequest\x12\x1e\n\nrecorderID\x18\x01\x20\x01(\tR\nreco\
    rderID\x12\x1c\n\tsessionID\x18\x02\x20\x01(\tR\tsessionID\"b\n\x0eSetNa\
    meRequest\x12\x1e\n\nrecorderID\x18\x01\x20\x01(\tR\nrecorderID\x12\x1c\
    \n\tsessionID\x18\x02\x20\x01(\tR\tsessionID\x12\x12\n\x04name\x18\x03\
    \x20\x01(\tR\x04name\"\xa2\x01\n\x14CreateSegmentRequest\x12\x1e\n\nreco\
    rderID\x18\x01\x20\x01(\tR\nrecorderID\x12\x1c\n\tsessionID\x18\x02\x20\
    \x01(\tR\tsessionID\x12\x1c\n\tsegmentID\x18\x03\x20\x01(\tR\tsegmentID\
    \x12.\n\x04info\x18\x04\x20\x01(\x0b2\x1a.sessionsource.SegmentInfoR\x04\
    info\"\xa2\x01\n\x14UpdateSegmentRequest\x12\x1e\n\nrecorderID\x18\x01\
    \x20\x01(\tR\nrecorderID\x12\x1c\n\tsessionID\x18\x02\x20\x01(\tR\tsessi\
    onID\x12\x1c\n\tsegmentID\x18\x03\x20\x01(\tR\tsegmentID\x12.\n\x04info\
    \x18\x04\x20\x01(\x0b2\x1a.sessionsource.SegmentInfoR\x04info\"r\n\x14De\
    leteSegmentRequest\x12\x1e\n\nrecorderID\x18\x01\x20\x01(\tR\nrecorderID\
    \x12\x1c\n\tsessionID\x18\x02\x20\x01(\tR\tsessionID\x12\x1c\n\tsegmentI\
    D\x18\x03\x20\x01(\tR\tsegmentID\"r\n\x14RenderSegmentRequest\x12\x1e\n\
    \nrecorderID\x18\x01\x20\x01(\tR\nrecorderID\x12\x1c\n\tsessionID\x18\
    \x02\x20\x01(\tR\tsessionID\x12\x1c\n\tsegmentID\x18\x03\x20\x01(\tR\tse\
    gmentID\"3\n\x11CutSessionRequest\x12\x1e\n\nrecorderID\x18\x01\x20\x01(\
    \tR\nrecorderID*{\n\x0cSegmentState\x12\x19\n\x15SEGMENT_STATE_UNKNOWN\
    \x10\0\x12\x1b\n\x17SEGMENT_STATE_RENDERING\x10\x01\x12\x1a\n\x16SEGMENT\
    _STATE_FINISHED\x10\x02\x12\x17\n\x13SEGMENT_STATE_ERROR\x10\x03*b\n\x0c\
    SessionState\x12\x19\n\x15SESSION_STATE_UNKNOWN\x10\0\x12\x1b\n\x17SESSI\
    ON_STATE_RECORDING\x10\x01\x12\x1a\n\x16SESSION_STATE_FINISHED\x10\x022\
    \xdd\x05\n\rSessionSource\x12S\n\x0fStreamRecorders\x12%.sessionsource.S\
    treamRecordersRequest\x1a\x17.sessionsource.Recorder0\x01\x12O\n\x0eStre\
    amSessions\x12#.sessionsource.StreamSessionRequest\x1a\x16.sessionsource\
    .Session0\x01\x12G\n\x0eSetKeepSession\x12$.sessionsource.SetKeepSession\
    Request\x1a\x0f.common.Respone\x12E\n\rDeleteSession\x12#.sessionsource.\
    DeleteSessionRequest\x1a\x0f.common.Respone\x129\n\x07SetName\x12\x1d.se\
    ssionsource.SetNameRequest\x1a\x0f.common.Respone\x12E\n\rCreateSegment\
    \x12#.sessionsource.CreateSegmentRequest\x1a\x0f.common.Respone\x12E\n\r\
    DeleteSegment\x12#.sessionsource.DeleteSegmentRequest\x1a\x0f.common.Res\
    pone\x12E\n\rRenderSegment\x12#.sessionsource.RenderSegmentRequest\x1a\
    \x0f.common.Respone\x12E\n\rUpdateSegment\x12#.sessionsource.UpdateSegme\
    ntRequest\x1a\x0f.common.Respone\x12?\n\nCutSession\x12\x20.sessionsourc\
    e.CutSessionRequest\x1a\x0f.common.ResponeBEZCgithub.com/pascalhuerst/se\
    ssion-recorder/protocols/go/sessionsourceJ\xea\x20\n\x07\x12\x05\0\0\x95\
    \x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\
    \x16\n\t\n\x02\x03\0\x12\x03\x04\0\x16\n\t\n\x02\x03\x01\x12\x03\x05\0)\
    \n\t\n\x02\x03\x02\x12\x03\x06\0(\n\x08\n\x01\x08\x12\x03\x08\0Z\n\t\n\
    \x02\x08\x0b\x12\x03\x08\0Z\n\t\n\x02\x04\0\x12\x03\n\0!\n\n\n\x03\x04\0\
    \x01\x12\x03\n\x08\x1e\n\t\n\x02\x04\x01\x12\x03\x0c\0\x1b\n\n\n\x03\x04\
    \x01\x01\x12\x03\x0c\x08\x18\n\n\n\x02\x04\x02\x12\x04\x0e\0\x16\x01\n\n\
    \n\x03\x04\x02\x01\x12\x03\x0e\x08\x10\n\x0b\n\x04\x04\x02\x02\0\x12\x03\
    \x0f\x08\x1e\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x0f\x08\x0e\n\x0c\n\
    \x05\x04\x02\x02\0\x01\x12\x03\x0f\x0f\x19\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x03\x0f\x1c\x1d\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x10\x08\x20\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03\x10\x08\x0e\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03\x10\x0f\x1b\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\
    \x10\x1e\x1f\n\x0c\n\x04\x04\x02\x08\0\x12\x04\x12\x08\x15\t\n\x0c\n\x05\
    \x04\x02\x08\0\x01\x12\x03\x12\x0e\x12\n\x0b\n\x04\x04\x02\x02\x02\x12\
    \x03\x13\x101\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03\x13\x10%\n\x0c\n\
    \x05\x04\x02\x02\x02\x01\x12\x03\x13&,\n\x0c\n\x05\x04\x02\x02\x02\x03\
    \x12\x03\x13/0\n\x0b\n\x04\x04\x02\x02\x03\x12\x03\x14\x10-\n\x0c\n\x05\
    \x04\x02\x02\x03\x06\x12\x03\x14\x10\x20\n\x0c\n\x05\x04\x02\x02\x03\x01\
    \x12\x03\x14!(\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\x14+,\n\n\n\x02\
    \x04\x03\x12\x04\x18\0\x1a\x01\n\n\n\x03\x04\x03\x01\x12\x03\x18\x08\x1c\
    \n\x0b\n\x04\x04\x03\x02\0\x12\x03\x19\x08\x1e\n\x0c\n\x05\x04\x03\x02\0\
    \x05\x12\x03\x19\x08\x0e\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x19\x0f\
    \x19\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x19\x1c\x1d\n\n\n\x02\x05\0\
    \x12\x04\x1c\0!\x01\n\n\n\x03\x05\0\x01\x12\x03\x1c\x05\x11\n\x0b\n\x04\
    \x05\0\x02\0\x12\x03\x1d\x08\"\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x1d\
    \x08\x1d\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x1d\x20!\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\x1e\x08$\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x1e\x08\
    \x1f\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x1e\"#\n\x0b\n\x04\x05\0\x02\
    \x02\x12\x03\x1f\x08#\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x1f\x08\x1e\
    \n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x1f!\"\n\x0b\n\x04\x05\0\x02\x03\
    \x12\x03\x20\x08\x20\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x20\x08\x1b\n\
    \x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x20\x1e\x1f\n\n\n\x02\x04\x04\x12\
    \x04#\0)\x01\n\n\n\x03\x04\x04\x01\x12\x03#\x08\x13\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x03$\x080\n\x0c\n\x05\x04\x04\x02\0\x06\x12\x03$\x08!\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03$\"+\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03\
    $./\n\x0b\n\x04\x04\x04\x02\x01\x12\x03%\x08.\n\x0c\n\x05\x04\x04\x02\
    \x01\x06\x12\x03%\x08!\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03%\")\n\x0c\
    \n\x05\x04\x04\x02\x01\x03\x12\x03%,-\n\x0b\n\x04\x04\x04\x02\x02\x12\
    \x03'\x08\x18\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03'\x08\x0e\n\x0c\n\
    \x05\x04\x04\x02\x02\x01\x12\x03'\x0f\x13\n\x0c\n\x05\x04\x04\x02\x02\
    \x03\x12\x03'\x16\x17\n\x0b\n\x04\x04\x04\x02\x03\x12\x03(\x08\x1f\n\x0c\
    \n\x05\x04\x04\x02\x03\x06\x12\x03(\x08\x14\n\x0c\n\x05\x04\x04\x02\x03\
    \x01\x12\x03(\x15\x1a\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03(\x1d\x1e\n\
    \t\n\x02\x04\x05\x12\x03+\0\x19\n\n\n\x03\x04\x05\x01\x12\x03+\x08\x16\n\
    \n\n\x02\x04\x06\x12\x04-\04\x01\n\n\n\x03\x04\x06\x01\x12\x03-\x08\x0f\
    \n\x0b\n\x04\x04\x06\x02\0\x12\x03.\x08\x1d\n\x0c\n\x05\x04\x06\x02\0\
    \x05\x12\x03.\x08\x0e\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03.\x0f\x18\n\
    \x0c\n\x05\x04\x06\x02\0\x03\x12\x03.\x1b\x1c\n\x0c\n\x04\x04\x06\x08\0\
    \x12\x040\x083\t\n\x0c\n\x05\x04\x06\x08\0\x01\x12\x030\x0e\x12\n\x0b\n\
    \x04\x04\x06\x02\x01\x12\x031\x10(\n\x0c\n\x05\x04\x06\x02\x01\x06\x12\
    \x031\x10\x1b\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x031\x1c#\n\x0c\n\x05\
    \x04\x06\x02\x01\x03\x12\x031&'\n\x0b\n\x04\x04\x06\x02\x02\x12\x032\x10\
    +\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\x032\x10\x1e\n\x0c\n\x05\x04\x06\
    \x02\x02\x01\x12\x032\x1f&\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x032)*\n\
    \n\n\x02\x05\x01\x12\x046\0:\x01\n\n\n\x03\x05\x01\x01\x12\x036\x05\x11\
    \n\x0b\n\x04\x05\x01\x02\0\x12\x037\x08\"\n\x0c\n\x05\x05\x01\x02\0\x01\
    \x12\x037\x08\x1d\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x037\x20!\n\x0b\n\
    \x04\x05\x01\x02\x01\x12\x038\x08$\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\
    \x038\x08\x1f\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x038\"#\n\x0b\n\x04\
    \x05\x01\x02\x02\x12\x039\x08#\n\x0c\n\x05\x05\x01\x02\x02\x01\x12\x039\
    \x08\x1e\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x039!\"\n\n\n\x02\x04\x07\
    \x12\x04<\0I\x01\n\n\n\x03\x04\x07\x01\x12\x03<\x08\x13\n\x0b\n\x04\x04\
    \x07\x02\0\x12\x03=\x082\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03=\x08!\n\
    \x0c\n\x05\x04\x07\x02\0\x01\x12\x03=\"-\n\x0c\n\x05\x04\x07\x02\0\x03\
    \x12\x03=01\n\x0b\n\x04\x04\x07\x02\x01\x12\x03>\x083\n\x0c\n\x05\x04\
    \x07\x02\x01\x06\x12\x03>\x08!\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03>\
    \".\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03>12\n\x0b\n\x04\x04\x07\x02\
    \x02\x12\x03?\x08.\n\x0c\n\x05\x04\x07\x02\x02\x06\x12\x03?\x08\x20\n\
    \x0c\n\x05\x04\x07\x02\x02\x01\x12\x03?!)\n\x0c\n\x05\x04\x07\x02\x02\
    \x03\x12\x03?,-\n\x0b\n\x04\x04\x07\x02\x03\x12\x03A\x08\x18\n\x0c\n\x05\
    \x04\x07\x02\x03\x05\x12\x03A\x08\x0e\n\x0c\n\x05\x04\x07\x02\x03\x01\
    \x12\x03A\x0f\x13\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03A\x16\x17\n\x0b\
    \n\x04\x04\x07\x02\x04\x12\x03B\x08!\n\x0c\n\x05\x04\x07\x02\x04\x05\x12\
    \x03B\x08\x0e\n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03B\x0f\x1c\n\x0c\n\
    \x05\x04\x07\x02\x04\x03\x12\x03B\x1f\x20\n\x0b\n\x04\x04\x07\x02\x05\
    \x12\x03C\x08$\n\x0c\n\x05\x04\x07\x02\x05\x05\x12\x03C\x08\x0e\n\x0c\n\
    \x05\x04\x07\x02\x05\x01\x12\x03C\x0f\x1f\n\x0c\n\x05\x04\x07\x02\x05\
    \x03\x12\x03C\"#\n\x0b\n\x04\x04\x07\x02\x06\x12\x03D\x08\x16\n\x0c\n\
    \x05\x04\x07\x02\x06\x05\x12\x03D\x08\x0c\n\x0c\n\x05\x04\x07\x02\x06\
    \x01\x12\x03D\r\x11\n\x0c\n\x05\x04\x07\x02\x06\x03\x12\x03D\x14\x15\n\
    \x0b\n\x04\x04\x07\x02\x07\x12\x03F\x08\x1f\n\x0c\n\x05\x04\x07\x02\x07\
    \x06\x12\x03F\x08\x14\n\x0c\n\x05\x04\x07\x02\x07\x01\x12\x03F\x15\x1a\n\
    \x0c\n\x05\x04\x07\x02\x07\x03\x12\x03F\x1d\x1e\n\x0b\n\x04\x04\x07\x02\
    \x08\x12\x03H\x08'\n\x0c\n\x05\x04\x07\x02\x08\x04\x12\x03H\x08\x10\n\
    \x0c\n\x05\x04\x07\x02\x08\x06\x12\x03H\x11\x18\n\x0c\n\x05\x04\x07\x02\
    \x08\x01\x12\x03H\x19!\n\x0c\n\x05\x04\x07\x02\x08\x03\x12\x03H$&\n\t\n\
    \x02\x04\x08\x12\x03K\0\x19\n\n\n\x03\x04\x08\x01\x12\x03K\x08\x16\n\n\n\
    \x02\x04\t\x12\x04M\0T\x01\n\n\n\x03\x04\t\x01\x12\x03M\x08\x0f\n\x0b\n\
    \x04\x04\t\x02\0\x12\x03N\x08\x16\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03N\
    \x08\x0e\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03N\x0f\x11\n\x0c\n\x05\x04\t\
    \x02\0\x03\x12\x03N\x14\x15\n\x0c\n\x04\x04\t\x08\0\x12\x04P\x08S\t\n\
    \x0c\n\x05\x04\t\x08\0\x01\x12\x03P\x0e\x12\n\x0b\n\x04\x04\t\x02\x01\
    \x12\x03Q\x10(\n\x0c\n\x05\x04\t\x02\x01\x06\x12\x03Q\x10\x1b\n\x0c\n\
    \x05\x04\t\x02\x01\x01\x12\x03Q\x1c#\n\x0c\n\x05\x04\t\x02\x01\x03\x12\
    \x03Q&'\n\x0b\n\x04\x04\t\x02\x02\x12\x03R\x10+\n\x0c\n\x05\x04\t\x02\
    \x02\x06\x12\x03R\x10\x1e\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03R\x1f&\n\
    \x0c\n\x05\x04\t\x02\x02\x03\x12\x03R)*\n\n\n\x02\x04\n\x12\x04V\0Z\x01\
    \n\n\n\x03\x04\n\x01\x12\x03V\x08\x1d\n\x0b\n\x04\x04\n\x02\0\x12\x03W\
    \x08\x1e\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03W\x08\x0e\n\x0c\n\x05\x04\n\
    \x02\0\x01\x12\x03W\x0f\x19\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03W\x1c\x1d\
    \n\x0b\n\x04\x04\n\x02\x01\x12\x03X\x08\x1d\n\x0c\n\x05\x04\n\x02\x01\
    \x05\x12\x03X\x08\x0e\n\x0c\n\x05\x04\n\x02\x01\x01\x12\x03X\x0f\x18\n\
    \x0c\n\x05\x04\n\x02\x01\x03\x12\x03X\x1b\x1c\n\x0b\n\x04\x04\n\x02\x02\
    \x12\x03Y\x08\x16\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03Y\x08\x0c\n\x0c\n\
    \x05\x04\n\x02\x02\x01\x12\x03Y\r\x11\n\x0c\n\x05\x04\n\x02\x02\x03\x12\
    \x03Y\x14\x15\n\n\n\x02\x04\x0b\x12\x04\\\0_\x01\n\n\n\x03\x04\x0b\x01\
    \x12\x03\\\x08\x1c\n\x0b\n\x04\x04\x0b\x02\0\x12\x03]\x08\x1e\n\x0c\n\
    \x05\x04\x0b\x02\0\x05\x12\x03]\x08\x0e\n\x0c\n\x05\x04\x0b\x02\0\x01\
    \x12\x03]\x0f\x19\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03]\x1c\x1d\n\x0b\n\
    \x04\x04\x0b\x02\x01\x12\x03^\x08\x1d\n\x0c\n\x05\x04\x0b\x02\x01\x05\
    \x12\x03^\x08\x0e\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03^\x0f\x18\n\x0c\
    \n\x05\x04\x0b\x02\x01\x03\x12\x03^\x1b\x1c\n\n\n\x02\x04\x0c\x12\x04a\0\
    e\x01\n\n\n\x03\x04\x0c\x01\x12\x03a\x08\x16\n\x0b\n\x04\x04\x0c\x02\0\
    \x12\x03b\x08\x1e\n\x0c\n\x05\x04\x0c\x02\0\x05\x12\x03b\x08\x0e\n\x0c\n\
    \x05\x04\x0c\x02\0\x01\x12\x03b\x0f\x19\n\x0c\n\x05\x04\x0c\x02\0\x03\
    \x12\x03b\x1c\x1d\n\x0b\n\x04\x04\x0c\x02\x01\x12\x03c\x08\x1d\n\x0c\n\
    \x05\x04\x0c\x02\x01\x05\x12\x03c\x08\x0e\n\x0c\n\x05\x04\x0c\x02\x01\
    \x01\x12\x03c\x0f\x18\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03c\x1b\x1c\n\
    \x0b\n\x04\x04\x0c\x02\x02\x12\x03d\x08\x18\n\x0c\n\x05\x04\x0c\x02\x02\
    \x05\x12\x03d\x08\x0e\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03d\x0f\x13\n\
    \x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03d\x16\x17\n\n\n\x02\x04\r\x12\x04g\
    \0l\x01\n\n\n\x03\x04\r\x01\x12\x03g\x08\x1c\n\x0b\n\x04\x04\r\x02\0\x12\
    \x03h\x08\x1e\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03h\x08\x0e\n\x0c\n\x05\
    \x04\r\x02\0\x01\x12\x03h\x0f\x19\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03h\
    \x1c\x1d\n\x0b\n\x04\x04\r\x02\x01\x12\x03i\x08\x1d\n\x0c\n\x05\x04\r\
    \x02\x01\x05\x12\x03i\x08\x0e\n\x0c\n\x05\x04\r\x02\x01\x01\x12\x03i\x0f\
    \x18\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03i\x1b\x1c\n\x0b\n\x04\x04\r\
    \x02\x02\x12\x03j\x08\x1d\n\x0c\n\x05\x04\r\x02\x02\x05\x12\x03j\x08\x0e\
    \n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03j\x0f\x18\n\x0c\n\x05\x04\r\x02\
    \x02\x03\x12\x03j\x1b\x1c\n\x0b\n\x04\x04\r\x02\x03\x12\x03k\x08\x1d\n\
    \x0c\n\x05\x04\r\x02\x03\x06\x12\x03k\x08\x13\n\x0c\n\x05\x04\r\x02\x03\
    \x01\x12\x03k\x14\x18\n\x0c\n\x05\x04\r\x02\x03\x03\x12\x03k\x1b\x1c\n\n\
    \n\x02\x04\x0e\x12\x04n\0s\x01\n\n\n\x03\x04\x0e\x01\x12\x03n\x08\x1c\n\
    \x0b\n\x04\x04\x0e\x02\0\x12\x03o\x08\x1e\n\x0c\n\x05\x04\x0e\x02\0\x05\
    \x12\x03o\x08\x0e\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03o\x0f\x19\n\x0c\n\
    \x05\x04\x0e\x02\0\x03\x12\x03o\x1c\x1d\n\x0b\n\x04\x04\x0e\x02\x01\x12\
    \x03p\x08\x1d\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03p\x08\x0e\n\x0c\n\
    \x05\x04\x0e\x02\x01\x01\x12\x03p\x0f\x18\n\x0c\n\x05\x04\x0e\x02\x01\
    \x03\x12\x03p\x1b\x1c\n\x0b\n\x04\x04\x0e\x02\x02\x12\x03q\x08\x1d\n\x0c\
    \n\x05\x04\x0e\x02\x02\x05\x12\x03q\x08\x0e\n\x0c\n\x05\x04\x0e\x02\x02\
    \x01\x12\x03q\x0f\x18\n\x0c\n\x05\x04\x0e\x02\x02\x03\x12\x03q\x1b\x1c\n\
    \x0b\n\x04\x04\x0e\x02\x03\x12\x03r\x08\x1d\n\x0c\n\x05\x04\x0e\x02\x03\
    \x06\x12\x03r\x08\x13\n\x0c\n\x05\x04\x0e\x02\x03\x01\x12\x03r\x14\x18\n\
    \x0c\n\x05\x04\x0e\x02\x03\x03\x12\x03r\x1b\x1c\n\n\n\x02\x04\x0f\x12\
    \x04u\0y\x01\n\n\n\x03\x04\x0f\x01\x12\x03u\x08\x1c\n\x0b\n\x04\x04\x0f\
    \x02\0\x12\x03v\x08\x1e\n\x0c\n\x05\x04\x0f\x02\0\x05\x12\x03v\x08\x0e\n\
    \x0c\n\x05\x04\x0f\x02\0\x01\x12\x03v\x0f\x19\n\x0c\n\x05\x04\x0f\x02\0\
    \x03\x12\x03v\x1c\x1d\n\x0b\n\x04\x04\x0f\x02\x01\x12\x03w\x08\x1d\n\x0c\
    \n\x05\x04\x0f\x02\x01\x05\x12\x03w\x08\x0e\n\x0c\n\x05\x04\x0f\x02\x01\
    \x01\x12\x03w\x0f\x18\n\x0c\n\x05\x04\x0f\x02\x01\x03\x12\x03w\x1b\x1c\n\
    \x0b\n\x04\x04\x0f\x02\x02\x12\x03x\x08\x1d\n\x0c\n\x05\x04\x0f\x02\x02\
    \x05\x12\x03x\x08\x0e\n\x0c\n\x05\x04\x0f\x02\x02\x01\x12\x03x\x0f\x18\n\
    \x0c\n\x05\x04\x0f\x02\x02\x03\x12\x03x\x1b\x1c\n\n\n\x02\x04\x10\x12\
    \x04{\0\x7f\x01\n\n\n\x03\x04\x10\x01\x12\x03{\x08\x1c\n\x0b\n\x04\x04\
    \x10\x02\0\x12\x03|\x08\x1e\n\x0c\n\x05\x04\x10\x02\0\x05\x12\x03|\x08\
    \x0e\n\x0c\n\x05\x04\x10\x02\0\x01\x12\x03|\x0f\x19\n\x0c\n\x05\x04\x10\
    \x02\0\x03\x12\x03|\x1c\x1d\n\x0b\n\x04\x04\x10\x02\x01\x12\x03}\x08\x1d\
    \n\x0c\n\x05\x04\x10\x02\x01\x05\x12\x03}\x08\x0e\n\x0c\n\x05\x04\x10\
    \x02\x01\x01\x12\x03}\x0f\x18\n\x0c\n\x05\x04\x10\x02\x01\x03\x12\x03}\
    \x1b\x1c\n\x0b\n\x04\x04\x10\x02\x02\x12\x03~\x08\x1d\n\x0c\n\x05\x04\
    \x10\x02\x02\x05\x12\x03~\x08\x0e\n\x0c\n\x05\x04\x10\x02\x02\x01\x12\
    \x03~\x0f\x18\n\x0c\n\x05\x04\x10\x02\x02\x03\x12\x03~\x1b\x1c\n\x0c\n\
    \x02\x04\x11\x12\x06\x81\x01\0\x83\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\x81\x01\x08\x19\n\x0c\n\x04\x04\x11\x02\0\x12\x04\x82\x01\x08\x1e\n\
    \r\n\x05\x04\x11\x02\0\x05\x12\x04\x82\x01\x08\x0e\n\r\n\x05\x04\x11\x02\
    \0\x01\x12\x04\x82\x01\x0f\x19\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\x82\
    \x01\x1c\x1d\n\x0c\n\x02\x06\0\x12\x06\x85\x01\0\x95\x01\x01\n\x0b\n\x03\
    \x06\0\x01\x12\x04\x85\x01\x08\x15\n\x16\n\x04\x06\0\x02\0\x12\x04\x87\
    \x01\x08N\x1a\x08\x20Stream\n\n\r\n\x05\x06\0\x02\0\x01\x12\x04\x87\x01\
    \x0c\x1b\n\r\n\x05\x06\0\x02\0\x02\x12\x04\x87\x01\x1c2\n\r\n\x05\x06\0\
    \x02\0\x06\x12\x04\x87\x01=C\n\r\n\x05\x06\0\x02\0\x03\x12\x04\x87\x01DL\
    \n\x0c\n\x04\x06\0\x02\x01\x12\x04\x88\x01\x08J\n\r\n\x05\x06\0\x02\x01\
    \x01\x12\x04\x88\x01\x0c\x1a\n\r\n\x05\x06\0\x02\x01\x02\x12\x04\x88\x01\
    \x1b/\n\r\n\x05\x06\0\x02\x01\x06\x12\x04\x88\x01:@\n\r\n\x05\x06\0\x02\
    \x01\x03\x12\x04\x88\x01AH\n\x15\n\x04\x06\0\x02\x02\x12\x04\x8b\x01\x08\
    K\x1a\x07\x20Unary\n\n\r\n\x05\x06\0\x02\x02\x01\x12\x04\x8b\x01\x0c\x1a\
    \n\r\n\x05\x06\0\x02\x02\x02\x12\x04\x8b\x01\x1b0\n\r\n\x05\x06\0\x02\
    \x02\x03\x12\x04\x8b\x01;I\n\x0c\n\x04\x06\0\x02\x03\x12\x04\x8c\x01\x08\
    I\n\r\n\x05\x06\0\x02\x03\x01\x12\x04\x8c\x01\x0c\x19\n\r\n\x05\x06\0\
    \x02\x03\x02\x12\x04\x8c\x01\x1a.\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\
    \x8c\x019G\n\x0c\n\x04\x06\0\x02\x04\x12\x04\x8d\x01\x08=\n\r\n\x05\x06\
    \0\x02\x04\x01\x12\x04\x8d\x01\x0c\x13\n\r\n\x05\x06\0\x02\x04\x02\x12\
    \x04\x8d\x01\x14\"\n\r\n\x05\x06\0\x02\x04\x03\x12\x04\x8d\x01-;\n\x0c\n\
    \x04\x06\0\x02\x05\x12\x04\x8f\x01\x08I\n\r\n\x05\x06\0\x02\x05\x01\x12\
    \x04\x8f\x01\x0c\x19\n\r\n\x05\x06\0\x02\x05\x02\x12\x04\x8f\x01\x1a.\n\
    \r\n\x05\x06\0\x02\x05\x03\x12\x04\x8f\x019G\n\x0c\n\x04\x06\0\x02\x06\
    \x12\x04\x90\x01\x08I\n\r\n\x05\x06\0\x02\x06\x01\x12\x04\x90\x01\x0c\
    \x19\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x90\x01\x1a.\n\r\n\x05\x06\0\
    \x02\x06\x03\x12\x04\x90\x019G\n\x0c\n\x04\x06\0\x02\x07\x12\x04\x91\x01\
    \x08I\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\x91\x01\x0c\x19\n\r\n\x05\x06\
    \0\x02\x07\x02\x12\x04\x91\x01\x1a.\n\r\n\x05\x06\0\x02\x07\x03\x12\x04\
    \x91\x019G\n\x0c\n\x04\x06\0\x02\x08\x12\x04\x92\x01\x08I\n\r\n\x05\x06\
    \0\x02\x08\x01\x12\x04\x92\x01\x0c\x19\n\r\n\x05\x06\0\x02\x08\x02\x12\
    \x04\x92\x01\x1a.\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\x92\x019G\n\x0c\n\
    \x04\x06\0\x02\t\x12\x04\x94\x01\x08C\n\r\n\x05\x06\0\x02\t\x01\x12\x04\
    \x94\x01\x0c\x16\n\r\n\x05\x06\0\x02\t\x02\x12\x04\x94\x01\x17(\n\r\n\
    \x05\x06\0\x02\t\x03\x12\x04\x94\x013Ab\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::common::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            deps.push(::protobuf::well_known_types::duration::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(18);
            messages.push(StreamRecordersRequest::generated_message_descriptor_data());
            messages.push(RecordereRemoved::generated_message_descriptor_data());
            messages.push(Recorder::generated_message_descriptor_data());
            messages.push(StreamSessionRequest::generated_message_descriptor_data());
            messages.push(SegmentInfo::generated_message_descriptor_data());
            messages.push(SegmentRemoved::generated_message_descriptor_data());
            messages.push(Segment::generated_message_descriptor_data());
            messages.push(SessionInfo::generated_message_descriptor_data());
            messages.push(SessionRemoved::generated_message_descriptor_data());
            messages.push(Session::generated_message_descriptor_data());
            messages.push(SetKeepSessionRequest::generated_message_descriptor_data());
            messages.push(DeleteSessionRequest::generated_message_descriptor_data());
            messages.push(SetNameRequest::generated_message_descriptor_data());
            messages.push(CreateSegmentRequest::generated_message_descriptor_data());
            messages.push(UpdateSegmentRequest::generated_message_descriptor_data());
            messages.push(DeleteSegmentRequest::generated_message_descriptor_data());
            messages.push(RenderSegmentRequest::generated_message_descriptor_data());
            messages.push(CutSessionRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(SegmentState::generated_enum_descriptor_data());
            enums.push(SessionState::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
